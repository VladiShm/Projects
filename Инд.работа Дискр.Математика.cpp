#include "iostream" //манипулятор основных процессов
#include "iomanip" //манипулятор вывода
#include "vector" //динамич массивы-контейнеры
#include "list" //двусвязные списки
#include "fstream" //файлы
#include "stack" //список-стек
using namespace std;

int main()
{
    // ввод графа
    setlocale(LC_ALL, "Russian");
    ifstream f1("input.txt", ios::in);
    ofstream f2("output.txt", ios::out);
    int n; //число строк/столбцов/вершин
    f1 >> n;
    vector < vector<int> > g(n, vector<int>(n)); //двумерный список вершин, матрица смежности
    for (int i = 0; i < n; i++) //чтение графа в матрицу смежности
    {
        for (int j = 0; j < n; j++)
        {
            f1 >> g[i][j];
        }
    }

    //подсчет степеней вершин и поиск начальной вершины
    vector<int> deg(n); //подсчет степеней вершин каждой вершины
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            deg[i] += g[i][j];
    int first = 0;
    while (!deg[first])  //ищем ненулевую степень у вершин с которой мы и будем начинать ход
    {
        ++first;
    }

    //определение эйлеровости графа и поиск нечетных вершин
    int v1 = -1, v2 = -1; //v1 - это 1 переменная для цепи, v2 - 2 переменная для цепи (вход и выход для цепи)
    bool bad = false; //переменная, кот-ая возвращает 0 если граф не эйлеровый
    for (int i = 0; i < n; ++i)
        if (deg[i] & 1) //если вершина не четна
            if (v1 == -1)
                v1 = i;
            else
                if (v2 == -1)
                    v2 = i;
                else
                    bad = true; //если нечетных вершин больше двух - ни цепь, ни цикл не построить

    //если есть нечетные вершины в графе, строим дополнительное ребро для построения цикла
    if (v1 != -1) //если в графе цепь
    {
        ++g[v1][v2], ++g[v2][v1]; //строим дополнительное ребро для построения и в итоге будут все четные вершины => эйлеров цикл будет сущ-ть
    }

    //поиск цикла в графе
    stack <int> st; //создаем стек
    st.push(first); //добавим первую вершину в стек
    vector <int> res;
    if (!bad) //если граф эйлеровый
    {
        while (!st.empty()) //пока стек не пустой, ищем цикл в графе
        {   //при цепи: при ребре-мосте (при нечетн вершинах, цепях соотв-но), зацикливается цикл при не пройденном до конца графе, путей из вершины тогда не находится, i = n, поэтому стек начинает перезаписывать до своего обнуления в массив вывода, но наоборот(учитывается пройденное-ребро мост по алгоритму флери, поэтому цикл переворачивается, а соединенные ребром нечетные вершины (с цифрой 2, если ребро между ними уже есть, оно учитывается и как бы уже есть в цикле, поэтому ошибки не происходит, два ребра разбиваются, один в стек, другой все еще в графе), поэтому цикл не зацикливается дальше и идет правильно, все ребра проходятся, цепь найдена, после прохода всего графа после этой рокировки все нормально вставляется в выходной массив
            //при цикле - программа спокойно находит любой цикл
            int v = st.top(); //вызываем верхний элемент стека, это номер вершины и с помощью нее мы выбираем куда идти по строке где есть 1
            int i;
            for (i = 0; i < n; ++i) //если цикл доходит до конца то из-за ++i    i = n
            {
                if (g[v][i]) //если ребро есть - завершение
                {
                    break;
                }
            }
            if (i == n) //если цикл доходит до конца(строка пуста), вершина записывается в цепочку-массив ребер для вывода
            {
                res.push_back(v); //вставляем новый элемент в конец
                st.pop(); //удаляем верхний элемент
            }
            else //при эйлеровых цепях между нечетными вершинами достраивается ребро тогда получается цепь а в последствии мы просто убираем это ребро и получается цепь
            {
                --g[v][i];
                --g[i][v]; //удаляем ребро чтобы не зациклился ход по матрице и во избежание повторок
                st.push(i); //добавляем элемент в верх стека и удаляем ребро в графе
            }
        }

        // если в графе цепь, удаляем лишнее ребро в результирующей цепи вершин
        if (v1 != -1)
            for (size_t i = 0; i + 1 < res.size(); ++i) //проискиваем в цикле по выводному массиву где у нас одна вершина будет равна нечетной первой а следующая за ней 2 нечетн или наоборот
                if (res[i] == v1 && res[i + 1] == v2 || res[i] == v2 && res[i + 1] == v1)
                { //size_t - беззнаковый целый тип данных
                    vector<int> res2;
                    for (size_t j = i + 1; j < res.size(); ++j) //переступаем через "лишнее" вставленное для нечетных вершин ребро в цепи и записываем весь путь после этого ребра в новый массив
                        res2.push_back(res[j]);
                    for (size_t j = 1; j <= i; ++j) //а теперь берем все вершины перед лишним ребром, но его опять же не берем
                        res2.push_back(res[j]);
                    res = res2; //изменяем результирующий массив буквально на одно значение, окончательно убираем лишнее ребро
                    break;
                }
        //доп проверка на связность
        for (int i = 0; i < n; ++i) //дополнительная проверка на то, связный ли граф (при оставшихся ребрах - нет)
            for (int j = 0; j < n; ++j)
            {
                if (g[i][j]) //учитываем случай если вдруг цикл поиска ошибся и какое-то ребро осталось, значит граф не эйлеровый
                {
                    bad = true;
                }
            }
        if (bad)
            f2 << "No" << endl;

    }
    // вывод и определение типа графа
    else //Если граф не эйлеровый, то выводим как есть, не тратим время зря при неэйлеровом графе
        f2 << "No" << endl;

    if (!bad) //если переменная определяющая, что граф эйлеровый, равна !1, то вывод соответв-ий
    {
        if (v1 != -1) //если нечетные вершины есть
        {
            f2 << "Chain" << endl;
            for (size_t i = 0; i < res.size(); ++i) //вывод прохода по цепи, если она есть
                f2 << res[i] + 1 << " ";
        }
        else
        {
            f2 << "Cycle" << endl;
            for (size_t i = 0; i < res.size() - 1; ++i) //вывод прохода по циклу, если он есть, без печати возвращения в начало
                f2 << res[i] + 1 << " ";
        }
    }
    cout << "Результаты находятся в выходном файле" << endl;
}